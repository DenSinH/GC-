#ifndef GC__SHADER_H
#define GC__SHADER_H

// fragmentShaderSource (from fragment.glsl, lines 0 to 11)
const char* fragmentShaderSource = 
"#version 400 core\n"
"out vec4 FragColor;\n"
"in vec4 vertexColor;\n"
"\n"
"void main()\n"
"{\n"
"    FragColor = vec4(vertexColor);\n"
"}\n";


// transformationShaderSource (from trafo.glsl, lines 0 to 39)
const char* transformationShaderSource = 
"#version 430 core\n"
"\n"
"layout (std430, binding = 4) buffer XF_SSBO\n"
"{\n"
"    float XF_A[0x100];\n"
"    float XF_B[0x100];\n"
"    float XF_C[0x100];\n"
"    float XF_D[0x100];\n"
"    float XF_regs[0x58];  // some regs are not floats, but most are\n"
"};\n"
"\n"
"vec4 transform(vec3 position, uint posidx) {\n"
"    // todo: general position matrix\n"
"    // this seems to be what libOGC makes from projection matrices\n"
"    mat4 projection = mat4(\n"
"        XF_regs[0x20], 0, 0, 0,  // first column\n"
"        0, XF_regs[0x22], 0, 0,  // second column\n"
"        0, 0, XF_regs[0x24], -1,  // third column\n"
"        XF_regs[0x21], XF_regs[0x23], XF_regs[0x25], 0  // fourth column\n"
"    );\n"
"\n"
"    // matrices can be accessed per row\n"
"    uint posmtx_base = posidx << 2;\n"
"    mat4 modelview = mat4(\n"
"        XF_A[posidx + 0], XF_A[posidx + 4], XF_A[posidx + 8], 0,\n"
"        XF_A[posidx + 1], XF_A[posidx + 5], XF_A[posidx + 9], 0,\n"
"        XF_A[posidx + 2], XF_A[posidx + 6], XF_A[posidx + 10], 0,\n"
"        XF_A[posidx + 3], XF_A[posidx + 7], XF_A[posidx + 11], 1\n"
"    );\n"
"\n"
"    vec4 pos = vec4(position, 1);\n"
"    pos = projection * modelview * pos;\n"
"    pos /= pos.w;\n"
"\n"
"    return pos;\n"
"}\n";


// vertexShaderSource (from vertex.glsl, lines 0 to 356)
const char* vertexShaderSource = 
"#version 430 core\n"
"\n"
"#undef DEBUG\n"
"\n"
"const uint draw_arg_POS = 9;\n"
"\n"
"uniform uint VCD_lo, VCD_hi;\n"
"uniform uint VAT_A, VAT_B, VAT_C;\n"
"uniform uint MATIDX_REG_A, MATIDX_REG_B;\n"
"\n"
"// here, the array is read as little endian\n"
"const int extract_offset[4] = { 0, 8, 16, 24 };\n"
"\n"
"layout (std430, binding = 3) buffer command_SSBO\n"
"{\n"
"    uint vertices;\n"
"    uint _command;\n"
"    uint vertex_stride;\n"
"    int arg_offsets[21];\n"
"    int data_offsets[12];\n"
"    uint array_strides[12];\n"
"    uint _data_size;  // data_size: I don't actually need this in the shader\n"
"    uint args[0x1140 >> 2];     // todo: generalize this\n"
"    uint data[];\n"
"};\n"
"\n"
"out vec4 vertexColor;\n"
"\n"
"/*\n"
" * I can't pass arrays to functions, so Ill have to make due writing separate read handlers for args/data\n"
" * */\n"
"#define read8(array) uint read8_ ## array ##(uint address) { return  bitfieldExtract(array[(address) >> 2], extract_offset[(address) & 3], 8); }\n"
"#define read8s(array) int read8s_ ## array ##(uint address) { return  bitfieldExtract(int(array[(address) >> 2]), extract_offset[(address) & 3], 8); }\n"
"\n"
"// bitfieldExtract sign extends the data for us when we pass signed ints!\n"
"#define read16(array) uint read16_ ## array ##(uint address) { \\\n"
"    uint msb = read8_ ## array ##(address); \\\n"
"    uint lsb = read8_ ## array ##(address + 1); \\\n"
"    return (msb << 8) | lsb; \\\n"
"}\n"
"\n"
"#define read16s(array) int read16s_ ## array ##(uint address) { \\\n"
"    int msb = read8s_ ## array ##(address); \\\n"
"    uint lsb = read8_ ## array ##(address + 1); \\\n"
"    return (msb << 8) | int(lsb); \\\n"
"}\n"
"\n"
"#define read32(array) uint read32_ ## array ##(uint address) { \\\n"
"    uint msh = read16_ ## array ##(address); \\\n"
"    uint lsh = read16_ ## array ##(address + 2); \\\n"
"    return (msh << 16) | lsh; \\\n"
"}\n"
"\n"
"#define read32s(array) int read32s_ ## array ##(uint address) { \\\n"
"    int msh = read16s_ ## array ##(address); \\\n"
"    uint lsh = read16_ ## array ##(address + 2); \\\n"
"    return (msh << 16) | int(lsh); \\\n"
"}\n"
"\n"
"read8(data);\n"
"read8s(data);\n"
"read8(args);\n"
"read8s(args);\n"
"\n"
"read16(data);\n"
"read16s(data);\n"
"read16(args);\n"
"read16s(args);\n"
"\n"
"read32(data);\n"
"read32s(data);\n"
"read32(args);\n"
"read32s(args);\n"
"\n"
"// defined in trafo.glsl\n"
"vec4 transform(vec3 position, uint posidx);\n"
"\n"
"void main()\n"
"{\n"
"    // used for all types of parameters\n"
"    uint arg_offset;\n"
"    uint data_offset;\n"
"\n"
"    int stemp;\n"
"    uint utemp;\n"
"\n"
"    if (arg_offsets[9] >= 0)\n"
"    {\n"
"        /* determine vertex position */\n"
"\n"
"        // initial values\n"
"        arg_offset = arg_offsets[9];\n"
"        arg_offset += gl_VertexID * vertex_stride;\n"
"\n"
"        uint POSVCD  = bitfieldExtract(VCD_lo, 9, 2);\n"
"        bool POSCNT  = bitfieldExtract(VAT_A, 0, 1) != 0;\n"
"        uint POSFMT  = bitfieldExtract(VAT_A, 1, 3);\n"
"        uint POSSHFT = bitfieldExtract(VAT_A, 4, 5);\n"
"\n"
"        vec3 position;\n"
"\n"
"        if (POSVCD > 1) {\n"
"            // indirect data\n"
"            data_offset = data_offsets[9 - draw_arg_POS];\n"
"\n"
"            // determine the \"GC vertex index\"\n"
"            int vertex_index;\n"
"            if (POSVCD == 2) {\n"
"                vertex_index = read8s_args(arg_offset);\n"
"            }\n"
"            else {\n"
"                vertex_index = read16s_args(arg_offset);\n"
"            }\n"
"            // todo: pass strides\n"
"            data_offset += vertex_index * array_strides[9 - draw_arg_POS];\n"
"\n"
"            // always load 3 coodinates, decide on whether to use the last one later\n"
"            switch (POSFMT) {\n"
"                case 0:  // u8\n"
"                    position.x = read8_data(data_offset);\n"
"                    position.y = read8_data(data_offset + 1);\n"
"                    position.z = read8_data(data_offset + 2);\n"
"                    break;\n"
"                case 1:  // s8\n"
"                    position.x = read8s_data(data_offset);\n"
"                    position.y = read8s_data(data_offset + 1);\n"
"                    position.z = read8s_data(data_offset + 2);\n"
"                    break;\n"
"                case 2:  // u16\n"
"                    position.x = read16_data(data_offset);\n"
"                    position.y = read16_data(data_offset + 2);\n"
"                    position.z = read16_data(data_offset + 4);\n"
"                    break;\n"
"                case 3:  // s16\n"
"                    position.x = read16s_data(data_offset);\n"
"                    position.y = read16s_data(data_offset + 2);\n"
"                    position.z = read16s_data(data_offset + 4);\n"
"                    break;\n"
"                case 4:\n"
"                    utemp = read32_data(data_offset);\n"
"                    position.x = uintBitsToFloat(utemp);\n"
"                    utemp = read32_data(data_offset + 4);\n"
"                    position.y = uintBitsToFloat(utemp);\n"
"                    utemp = read32_data(data_offset + 8);\n"
"                    position.z = uintBitsToFloat(utemp);\n"
"                    break;\n"
"                default:\n"
"                    // invalid format\n"
"                    return;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // read data from args\n"
"            // always load 3 coodinates, decide on whether to use the last one later\n"
"            switch (POSFMT) {\n"
"                case 0:  // u8\n"
"                    position.x = read8_args(arg_offset);\n"
"                    position.y = read8_args(arg_offset + 1);\n"
"                    position.z = read8_args(arg_offset + 2);\n"
"                    break;\n"
"                case 1:  // s8\n"
"                    position.x = read8s_args(arg_offset);\n"
"                    position.y = read8s_args(arg_offset + 1);\n"
"                    position.z = read8s_args(arg_offset + 2);\n"
"                    break;\n"
"                case 2:  // u16\n"
"                    position.x = read16_args(arg_offset);\n"
"                    position.y = read16_args(arg_offset + 2);\n"
"                    position.z = read16_args(arg_offset + 4);\n"
"                    break;\n"
"                case 3:  // s16\n"
"                    position.x = read16s_args(arg_offset);\n"
"                    position.y = read16s_args(arg_offset + 2);\n"
"                    position.z = read16s_args(arg_offset + 4);\n"
"                    break;\n"
"                case 4:\n"
"                    utemp = read32_args(arg_offset);\n"
"                    position.x = uintBitsToFloat(utemp);\n"
"                    utemp = read32_args(arg_offset + 4);\n"
"                    position.y = uintBitsToFloat(utemp);\n"
"                    utemp = read32_args(arg_offset + 8);\n"
"                    position.z = uintBitsToFloat(utemp);\n"
"                    break;\n"
"                default:\n"
"                    // invalid format\n"
"                    return;\n"
"            }\n"
"        }\n"
"\n"
"        // todo: POSSHFT\n"
"        if (!POSCNT) {\n"
"            // 2D\n"
"            position.z = 0;  // todo: what is this value supposed to be?\n"
"        }\n"
"\n"
"        uint posidx;\n"
"        if (arg_offsets[0] >= 0) {\n"
"            // position matrix index value passed (always direct)\n"
"            posidx = read8_args(arg_offsets[0]);\n"
"        }\n"
"        else {\n"
"            posidx = bitfieldExtract(MATIDX_REG_A, 0, 6);\n"
"        }\n"
"\n"
"        gl_Position = transform(position, posidx);\n"
"#ifdef DEBUG\n"
"        switch (gl_VertexID) {\n"
"            case 0:\n"
"                gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);\n"
"                break;\n"
"            case 1:\n"
"                gl_Position = vec4(0.5, -0.5, 0.0, 1.0);\n"
"                break;\n"
"            case 2:\n"
"                gl_Position = vec4(0.0, 0.5, 0.0, 1.0);\n"
"                break;\n"
"            default:\n"
"                gl_Position = vec4(position.xyz / 32.0, 1.0);\n"
"                break;\n"
"        }\n"
"#endif\n"
"    }\n"
"\n"
"    if (arg_offsets[11] >= 0)\n"
"    {\n"
"        /* determine vertex color 0 */\n"
"        // todo: different cases (right now only i8 indexed rgba8888\n"
"        // initial values\n"
"        arg_offset = arg_offsets[11];\n"
"        arg_offset += gl_VertexID * vertex_stride;\n"
"\n"
"        uint COL0VCD  = bitfieldExtract(VCD_lo, 13, 2);\n"
"        bool COL0CNT  = bitfieldExtract(VAT_A, 13, 1) != 0;\n"
"        uint COL0FMT  = bitfieldExtract(VAT_A, 14, 3);\n"
"\n"
"        vec4 color;\n"
"\n"
"        // todo: signed offset\n"
"        if (COL0VCD > 1) {\n"
"            // indirect data\n"
"            data_offset = data_offsets[11 - draw_arg_POS];\n"
"\n"
"            int color_index;\n"
"            if (COL0VCD == 2) {\n"
"                color_index = read8s_args(arg_offset);\n"
"            }\n"
"            else {\n"
"                color_index = read16s_args(arg_offset);\n"
"            }\n"
"\n"
"            data_offset += color_index * array_strides[11 - draw_arg_POS];\n"
"\n"
"            // always get 4 color value, determine actual value later\n"
"            switch (COL0FMT) {\n"
"                case 0:  // 16bit rgb565\n"
"                    utemp = read16_data(data_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 5)  / 32.0;\n"
"                    color.y = bitfieldExtract(utemp, 4, 6)  / 64.0;\n"
"                    color.z = bitfieldExtract(utemp, 10, 5) / 32.0;\n"
"                    color.w = 1.0;\n"
"                    break;\n"
"                case 1:  // 24bit rgb888\n"
"                    utemp = read32_data(data_offset);\n"
"                    color = unpackUnorm4x8(utemp).wzyx;  // BE to LE\n"
"                    color.w = 1.0;  // 3 colors\n"
"                    // already normalized\n"
"                    break;\n"
"                case 2:  // 32bit rgb888x\n"
"                    utemp = data[data_offset >> 2];  // data is 4 aligned\n"
"                    color = unpackUnorm4x8(utemp);\n"
"                    color.w = 1.0;  // 3 colors\n"
"                    // already normalized\n"
"                    break;\n"
"                case 3:  // 16bit rgba4444\n"
"                    utemp = read16_data(data_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 4);\n"
"                    color.y = bitfieldExtract(utemp, 3, 4);\n"
"                    color.z = bitfieldExtract(utemp, 7, 4);\n"
"                    color.w = bitfieldExtract(utemp, 11, 4);\n"
"                    color /= 16.0;  // normalize\n"
"                    break;\n"
"                case 4:  // 24bit rgba6666\n"
"                    utemp = read32_data(data_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 6);\n"
"                    color.y = bitfieldExtract(utemp, 5, 6);\n"
"                    color.z = bitfieldExtract(utemp, 11, 6);\n"
"                    color.w = bitfieldExtract(utemp, 17, 6);\n"
"                    color /= 64.0;  // normalize\n"
"                    break;\n"
"                case 5:  // 32bit rgba8888\n"
"                    utemp = data[data_offset >> 2];  // data is 4 aligned\n"
"                    color = unpackUnorm4x8(utemp);\n"
"                    // already normalized\n"
"                    break;\n"
"                default:\n"
"                    break;\n"
"            }\n"
"        }\n"
"        else {\n"
"            switch (COL0FMT) {\n"
"                case 0:  // 16bit rgb565\n"
"                    utemp = read16_args(arg_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 5)  / 32.0;\n"
"                    color.y = bitfieldExtract(utemp, 4, 6)  / 64.0;\n"
"                    color.z = bitfieldExtract(utemp, 10, 5) / 32.0;\n"
"                    color.w = 1.0;\n"
"                    break;\n"
"                case 1:  // 24bit rgb888\n"
"                case 2:  // 32bit rgb888x\n"
"                    utemp = read32_args(arg_offset);\n"
"                    color = unpackUnorm4x8(utemp).wzyx;  // BE to LE\n"
"                    color.w = 1.0;  // 3 colors\n"
"                    // already normalized\n"
"                    break;\n"
"                case 3:  // 16bit rgba4444\n"
"                    utemp = read16_args(arg_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 4);\n"
"                    color.y = bitfieldExtract(utemp, 3, 4);\n"
"                    color.z = bitfieldExtract(utemp, 7, 4);\n"
"                    color.w = bitfieldExtract(utemp, 11, 4);\n"
"                    color /= 16.0;  // normalize\n"
"                    break;\n"
"                case 4:  // 24bit rgba6666\n"
"                    utemp = read32_args(arg_offset);\n"
"                    color.x = bitfieldExtract(utemp, 0, 6);\n"
"                    color.y = bitfieldExtract(utemp, 5, 6);\n"
"                    color.z = bitfieldExtract(utemp, 11, 6);\n"
"                    color.w = bitfieldExtract(utemp, 17, 6);\n"
"                    color /= 64.0;  // normalize\n"
"                    break;\n"
"                case 5:  // 32bit rgba8888\n"
"                    utemp = read32_args(arg_offset);\n"
"                    color = unpackUnorm4x8(utemp).wzyx;  // BE to LE\n"
"                    // already normalized\n"
"                    break;\n"
"                default:\n"
"                    break;\n"
"            }\n"
"        }\n"
"\n"
"        // todo: I am not sure if COLCNT really does anything, but just to be sure\n"
"        vertexColor = color;\n"
"        if (!COL0CNT) color.w = 1.0;\n"
"#ifdef DEBUG\n"
"        if (position.z == 0) {\n"
"            vertexColor = vec4(0.0, position.y / 32.0, 0.0, 1.0);\n"
"        }\n"
"        else {\n"
"            vertexColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n";

#endif  // GC__SHADER_H